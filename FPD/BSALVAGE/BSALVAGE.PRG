*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*        08/15/97            BSALVAGE.PRG               13:00:06 
*                                                                
*       픔컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*        Author's Name                                           
*                                                                
*        Copyright (c) 1997 Company Name                         
*        Address                                                 
*        City,     Zip                                           
*                                                                
*        Description:                                            
*        This program was automatically generated by GENSCRN.    
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴


#REGION 0
REGIONAL m.currarea, m.talkstat, m.compstat

IF SET("TALK") = "ON"
	SET TALK OFF
	m.talkstat = "ON"
ELSE
	m.talkstat = "OFF"
ENDIF
m.compstat = SET("COMPATIBLE")
SET COMPATIBLE FOXPLUS

*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*                       MS-DOS Window definitions                
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*

IF NOT WEXIST("_rn60r8lzq")
	DEFINE WINDOW _rn60r8lzq ;
		FROM 0, 0 ;
		TO 17,79 ;
		TITLE "Visual file pieces salvage" ;
		FLOAT ;
		NOCLOSE ;
		NOMINIMIZE ;
		NONE ;
		COLOR SCHEME 1
ENDIF


*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*                BSALVAGE/MS-DOS Setup Code - SECTION 2          
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*

#REGION 1
#DEFINE Tstng .F.
#IF Tstng
*** Temporary for testing...
FileLen = 17786
EofMark = 1
FirstRecPos = 417
DBFhandle = FOPEN("sample5.dbf",2)
RecordLen = 167
USE sample5.def ALIAS RecoverDef
VFP = .F.
SET PROCEDURE TO recover.prg
*** End Temporary for testing
#ENDIF

PRIVATE BlockArray, BlockList, FilePos, CurFilePos, RecPosNum, FstTRPos, RECS
PRIVATE BlockCount, Wheight, Wwidth, Bheight, OldRPN, Nrecs, RecStr
PRIVATE FileText, FileRecords, SensLvl

SensLvl = RScanLevel
FileText = ''
DIMENSION RecStr[3]
RecStr=''
FileRecords = (FileLen - EofMark - FirstRecPos)/RecordLen && should be
SensLvl = IIF(FileRecords<3000, 2, RScanLevel)
RECS = 1
** these may not be needed in VFP
Wheight = 19.00 && bsalvage window vertical size
Wwidth =  80.00 && ............... horizontal size
Bheight = 4.00 && record browse window height.

Nrecs = 1 && number of records shown in File Record Viewer
FstTRPos = Cr_RecT() && create temp filepos browse file
FilePos = FirstRecPos
CurFilePos = FilePos
RecPosNum = (FilePos - FirstRecPos)/RecordLen + 1 && 1st record is #1
OldRPN = RecPosNum
BlockCount = 0 && blockcounter for BlockList
DIMENSION BlockArray [1]
BlockArray[1] = "StartRecPos EndRecPos"
BlockList = ''
CRLF = CHR(13)+CHR(10)

*** Block marker mouse indicators
PRIVATE TextStart
PRIVATE BrLines, LineChars, BrSize, FirstCY, FirstCX
FirstCY = 1 && Y start pos of 1st displayed char on screen in white rectangle
FirstCX = 1 && X start pos of 1st displayed char on screen in white rectangle
brlines = 13 && number of browse lines in box
LineChars = 50 && number of characters per line
TextStart = -1 && first char file pos of text display - initially unknown (-1)
brsize = brlines*LineChars && characters in browse box
ON KEY LABEL MOUSE DO showpos

=GetBrowse() && get record browse window


*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*                     BSALVAGE/MS-DOS Screen Layout              
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*

#REGION 1
IF WVISIBLE("_rn60r8lzq")
	ACTIVATE WINDOW _rn60r8lzq SAME
ELSE
	ACTIVATE WINDOW _rn60r8lzq NOSHOW
ENDIF
@ 15,48,17,71 BOX REPLICATE(" ",8)+" "
@ 15,48 FILL TO 17,71 ;
	COLOR N+/W    
@ 1,1,17,50 BOX REPLICATE(" ",8)+" "
@ 1,1 FILL TO 17,50 ;
	COLOR N+/W    
@ 3,51,12,79 BOX "旼엿耗윰 "
@ 3,51 FILL TO 12,79 ;
	COLOR B+/W    
@ 0,32 SAY "Records?" ;
	SIZE 1,8, 0
@ 0,0 SAY "EOF:" ;
	SIZE 1,4, 0
@ 0,14 SAY "RecSize:" ;
	SIZE 1,8, 0
@ 0,3 SAY FileLen - 1 ;
	SIZE 1,8 ;
	PICTURE "@B"
@ 0,22 SAY RecordLen ;
	SIZE 1,5 ;
	PICTURE "@B ####"
@ 0,40 SAY FileRecords ;
	SIZE 1,8 ;
	PICTURE "@B"
@ 0,58 GET Instrs ;
	PICTURE "@*HN Instructions" ;
	SIZE 1,15,1 ;
	DEFAULT 1 ;
	VALID INSTRSV() ;
	COLOR SCHEME 7
@ 2,55 GET OkCanc ;
	PICTURE "@*HT Done;Cancel" ;
	SIZE 1,10,0 ;
	DEFAULT 1
@ 4,68 GET CancBl ;
	PICTURE "@*HN Undo Last" ;
	SIZE 1,11,1 ;
	DEFAULT 1 ;
	VALID CancBlV()
@ 5,52 GET BlockList ;
 	PICTURE "@&N" ;
	FROM BlockArray ;
	SIZE 6,27 ;
	DEFAULT 1 ;
	COLOR SCHEME 2
@ 11,53 GET MarkBlock ;
	PICTURE "@*HN MarkStrRec;MarkEndRec" ;
	SIZE 1,12,1 ;
	DEFAULT 1 ;
	VALID MarkBlockV()
@ 14,51 GET CheckRec ;
	PICTURE "@*HN CheckRecord" ;
	SIZE 1,13,1 ;
	DEFAULT 1 ;
	VALID CheckRecV()
@ 14,64 GET ChDel ;
	PICTURE "@*HN ToggleDelete" ;
	SIZE 1,14,1 ;
	DEFAULT 1 ;
	VALID ChDelV()
@ 15,3 GET NavL ;
	PICTURE "@*HN B;p" ;
	SIZE 1,3,0 ;
	DEFAULT 1 ;
	VALID NavV(NavL) ;
	COLOR SCHEME 10
@ 15,9 GET Recs ;
	SIZE 1,3 ;
	DEFAULT 0 ;
	PICTURE "@KB" ;
	VALID Recs>0
@ 15,12 GET NavR ;
	PICTURE "@*HN n;E" ;
	SIZE 1,3,0 ;
	DEFAULT 1 ;
	VALID NavV(NavR+4) ;
	COLOR SCHEME 10
@ 4,53 SAY "SavedBlock(s)" ;
	SIZE 1,13, 0 ;
	COLOR R/W     
@ 16,3 SAY "BOF   Recs  EOF" ;
	SIZE 1,15, 0 ;
	COLOR N+/W    
@ 14,1 TO 14,50 ;
	COLOR B/W     
@ 14,14 SAY " Record position controls " ;
	SIZE 1,26, 0 ;
	COLOR N/W     
@ 17,1 TO 17,71 ;
	COLOR B/W     
@ 15,34 SAY "Scan Quality:" ;
	SIZE 1,13, 0 ;
	COLOR N+/W    
@ 15,20 GET ScanRecs ;
	PICTURE "@*VN Scan good;Skip bad" ;
	SIZE 1,11,0 ;
	DEFAULT 1 ;
	VALID SCANRECS() ;
	COLOR SCHEME 10
@ 16,32 GET SensLvl ;
	PICTURE "@*RHN 1;2;3" ;
	SIZE 1,5,1 ;
	DEFAULT 1 ;
	COLOR SCHEME 10
@ 15,60 GET RecPosNum ;
	SIZE 1,10 ;
	DEFAULT 0 ;
	PICTURE "@KB" ;
	VALID RecPosNumV()
@ 16,60 GET FilePos ;
	SIZE 1,11 ;
	DEFAULT 0 ;
	PICTURE "@KB" ;
	VALID FilePosV()
@ 16,52 SAY "FilePos:" ;
	SIZE 1,8, 0 ;
	COLOR N+/W    
@ 15,53 SAY "RecNum:" ;
	SIZE 1,7, 0 ;
	COLOR N+/W    

IF NOT WVISIBLE("_rn60r8lzq")
	ACTIVATE WINDOW _rn60r8lzq
ENDIF

READ CYCLE ;
	WHEN BSALVAGEW()

RELEASE WINDOW _rn60r8lzq

#REGION 0
IF m.talkstat = "ON"
	SET TALK ON
ENDIF
IF m.compstat = "ON"
	SET COMPATIBLE ON
ENDIF


*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*                     BSALVAGE/MS-DOS Cleanup Code               
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*

#REGION 1
ON KEY LABEL MOUSE
USE IN recovert
ERASE recovert.dbf
ERASE recovert.fpt

********* Temporary for testing
*=FCLOSE(dbfhandle)
*USE IN recoverdef
*RETURN
*PROCEDURE x
********* END Temporary for testing

IF okcanc = 1
  IF blockcount>0
    DIMENSION blockarray[BlockCount+1]
    IF LEN(blockarray[BlockCount+1]) < 20
      tempno = VAL(LEFT(blockarray[BlockCount+1],11))
      blockarray[BlockCount+1] = blockarray[BlockCount+1];
        + STR(tempno+INT((FileLen-tempno)/recordlen)*recordlen - recordlen, 11, 0)
    ENDIF
    =ASORT(blockarray,2)
    PRIVATE i
    FOR i = 1 TO blockcount
      INSERT INTO _recoverpc VALUES(VAL(LEFT(blockarray[i+1],11)), VAL(RIGHT(blockarray[i+1],11)))
    ENDFOR
  ENDIF
  RETURN blockcount
ELSE
  RETURN 0
ENDIF



*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*         BSALVAGE/MS-DOS Supporting Procedures and Functions    
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*

#REGION 1
PROCEDURE Xpos
PARAMETER Fspot
RETURN INT((Fspot - TextStart) % LineChars) + FirstCX

PROCEDURE Ypos
PARAMETER Fspot
RETURN INT((Fspot - TextStart) / LineChars) + FirstCY

PROCEDURE ShowPos
* moves record pointer on mouse click
PRIVATE nx, ny TempNo
ny = INT(MROW()-.08)+1
nx = INT(MCOL()-.125)+1
IF !(nx>FirstCx-1 AND nx<(linechars+FirstCx) AND ny<brlines+FirstCY AND ny>FirstCY-1) OR !WONTOP('BSALVAGE')
  * Mouse click outside of square - and window must be top
  RETURN
ENDIF

TempNo = TextStart + (ny-FirstCY)*LineChars + (nx-FirstCx)
IF TempNo > FileLen - RecordLen/2 && cannot set pointer beyond begin + .5 of last record
  ?? CHR(7)
  RETURN
ENDIF
FilePos = TempNo
=FilePosV()
SHOW WINDOW Bsalvage REFRESH

*************************
PROCEDURE ShowText
* writes text to browse view area and moves mouse square
DO CASE
CASE FilePos < LineChars*(brlines-1) OR FileLen <= BrSize
  * near enough to start pos or small file
  TextStart = 0

CASE TextStart>-1 AND  (FilePos > TextStart + LineChars - 1);
    AND FilePos < TextStart + LineChars*(brlines-1) + 1
  * FilePos in correct range
  * just leave textstart as is

CASE FilePos > FileLen - BrSize + LineChars
  * change FilePos to FileLen - RecordLen  if beyond that
  * near end
  TextStart = FileLen - BrSize
OTHERWISE
  * generally in middle somewhere
  TextStart = INT(FilePos - BrSize/2 + LineChars/2)
ENDCASE

PRIVATE TempNo, i
=FSEEK(DBFHandle, TextStart)
FileText=FREAD(DBFhandle, brsize)

FileText = PADR(filetext, brsize) && just in case too small
* cover up previous 'text' if any
@ 1,1 FILL TO 14,50 COLOR W/W
* write the 'text'
** draw characters before record
FOR i = TextStart TO FilePos - 1
  @ Ypos(i), Xpos(i) + 0.1 SAY SUBSTR(FileText, i-TextStart+1, 1) ;
     COLOR N/W
ENDFOR

** draw red delete char
@ Ypos(FilePos), Xpos(FilePos) + 0.1 SAY SUBSTR(FileText, FilePos-TextStart+1, 1);
     COLOR W+/R
** draw record characters
TempNo = MIN(FilePos + RecordLen -1, TextStart+BrSize-1)
FOR i=FilePos+1 TO TempNo
  @ Ypos(i), Xpos(i) + 0.1 SAY SUBSTR(FileText, i-TextStart+1, 1) ;
    COLOR N/G
NEXT i
** draw chars to end of display
IF TempNo < TextStart + brsize - 1
  FOR i=TempNo+1 TO TextStart + brsize - 1
    @ Ypos(i), Xpos(i) + 0.1 SAY SUBSTR(FileText, i-TextStart+1, 1) ;
      COLOR N/W
  NEXT i
ENDIF
** Draw box around del char again
* SHOW GETS OFF && for BrPointer

PROCEDURE getbrowse
* creates browse view for records at FilePos
IF USED("RecoverT")
  USE IN recovert
ENDIF
PRIVATE i, Recnt
= FSEEK(dbfhandle, FilePos)
PRIVATE filehandle
filehandle = FOPEN("RecoverT.dbf", 2)
=FSEEK(filehandle, fsttrpos)

DO CASE
CASE FileLen - FilePos => 3*recordlen
  Recnt = MIN(nrecs,3)
CASE FileLen - FilePos => 2*recordlen
  Recnt = MIN(nrecs,2)
CASE FileLen - FilePos => recordlen/2
  Recnt = 1
ENDCASE

FOR i = 1 TO Recnt
  recstr[i]=FREAD(dbfhandle, recordlen)
  =FWRITE(filehandle, recstr[i])
ENDFOR

=putvalue(filehandle, 4, Recnt, 4,1)
=FCHSIZE(filehandle, fsttrpos + Recnt*(recordlen+1))
=FCLOSE(filehandle)
SELECT 0
USE recovert.dbf

DEFINE WINDOW _brow12 AT 19,0 SIZE 4, 78;
FLOAT NOGROW NOMINIMIZE NOZOOM NOCLOSE;
COLOR SCHEME 10
browwin='Record line-up viewer'
BROWSE TITLE browwin ;
  WINDOW _brow12 NODELETE NOAPPEND NOEDIT nowait
  * NOMENU
RELEASE WINDOW _brow12

Procedure RecPosNumV
FilePos = (RecPosNum -1)*recordlen+firstrecpos
=FilePosV()

PROCEDURE FilePosv
* moves file pointer to new pos.
IF CurFilePos = FilePos
  RETURN
ENDIF
IF  FilePos > FileLen - RecordLen/2 OR FilePos < 0
  FilePos = CurFilePos
  RecPosNum = (FilePos - firstrecpos)/recordlen + 1
  SHOW GET FilePos
  SHOW GET RecPosNum
  ?? CHR(7)
  RETURN
ENDIF
CurFilePos = FilePos
RecPosNum = (FilePos - firstrecpos)/recordlen + 1
oldrpn = RecPosNum
SHOW GET RecPosNum
SHOW GET FilePos
=ShowText()
=getbrowse()

PROCEDURE navv
PARAMETER navn
DO CASE
CASE navn = 1
  FilePos = 0
CASE navn = 2
  FilePos = FilePos - RECS*recordlen
  *CASE navn = 3
  *  FilePos = FilePos - 1
  *CASE navn = 4
  *  FilePos = FilePos + 1
CASE navn = 5
  FilePos = FilePos + RECS*recordlen
CASE navn = 6
  FilePos = FileLen - recordlen
ENDCASE
IF FilePos = CurFilePos
  RETURN
ENDIF
IF FilePos > FileLen - recordlen/2 OR FilePos < 0
  FilePos = CurFilePos
  RETURN
ENDIF
CurFilePos = FilePos
RecPosNum = (FilePos - firstrecpos)/recordlen + 1
oldrpn = RecPosNum
SHOW GET RecPosNum
SHOW GET FilePos
=ShowText()
=getbrowse()

********************
PROCEDURE CheckRecV
PRIVATE temps
temps = recval(recstr[Recno()],.T., Senslvl, .F.)
IF LEN(temps)>0
  =rMsgBox(temps, "Notice:",0)
ELSE
  =rMsgBox('Record appears OK!', "Notice:",0)
ENDIF
RETURN

*************************
PROCEDURE markblockv
* Marks first/last record in saved block
** check if left pressed and left already exists
** or right pressed and left doesnt exist
IF ((markblock=1 AND LEN(BlockArray[BlockCount+1])<20);
    OR (markblock=2 AND LEN(BlockArray[BlockCount+1])>20));
    AND blockcount>0)
  ?? CHR(7)
  RETURN
ENDIF
IF markblock = 1 && new left hand entry
  * check for overlaping blocks
  IF boverlap()
    RETURN
  ENDIF
  blockcount = blockcount+1
  DIMENSION blockarray[BlockCount+1]
  blockarray[BlockCount+1] = STR(FilePos, 11, 0)
ELSE && new right hand entry
  IF boverlap()
    RETURN
  ENDIF
  blockarray[BlockCount+1] = blockarray[BlockCount+1] + STR(FilePos, 11, 0)
ENDIF
blocklist = blockarray[BlockCount+1]
SHOW GET blocklist

**************
PROCEDURE boverlap
* checks for incorrect new position entry
* Check for integer block count
PRIVATE BC
IF LEN(BlockArray[BlockCount+1])<20 && this is a right hand entry - previous entry was left
  IF (FilePos - VAL(LEFT(BlockArray[BlockCount+1],11))) % recordlen !=0;
      OR FilePos < VAL(LEFT(BlockArray[BlockCount+1],11))
    ?? CHR(7)
    =rMsgBox("Block Start/End record positions do not match"+CHR(13)+"(or incorrect .def file)!", "Notice:",0)
    RETURN .T.
  ENDIF
  ** check for overlaps of this right entry
  BC = BlockCount-1
ELSE
  ** check for overlaps of this left entry
  BC = BlockCount
ENDIF
FOR ii = 1 TO BC
  IF VAL(LEFT(BlockArray[ii+1],11))<=FilePos AND;
      FilePos<=VAL(RIGHT(BlockArray[ii+1],11)) + RecordLen -1
    ?? CHR(7)
    =rMsgBox("Selected position overlaps a file block!", "Notice:",0)
    RETURN .T.
  ENDIF
ENDFOR
RETURN .F.

*********************
PROCEDURE cancblv
* Removes last block mark
IF blockcount=0
  RETURN
ENDIF
IF LEN(blockarray[BlockCount+1]) > 11
  blockarray[BlockCount+1] = LEFT(blockarray[BlockCount+1],11)
ELSE
  blockcount=blockcount-1
  DIMENSION blockarray[BlockCount+1]
ENDIF
blocklist = blockarray[BlockCount+1]
SHOW GET blocklist

**********************
PROCEDURE ChDelV
* Toggles delete flag
SELECT RecoverT
PRIVATE OldChar, NewChar
OldChar = GetString(DBFhandle, FilePos, 1)
IF OldChar == ' '
  NewChar = '*'
  DELETE
ELSE
  NewChar = ' '
  RECALL
ENDIF
IF rMsgBox("This changes the '" + OldChar + "' character to '" + NewChar;
+ "'. Original character may be lost if you change your mind!" + chr(13)  + chr(13) + "Continue?", "Notice:", 1)=2
  RETURN
ENDIF
=PutString(DBFhandle, FilePos, NewChar)
FileText=STUFF(FileText, FilePos-TextStart+1, 1, NewChar)
RecStr[1] = STUFF(RecStr[1], 1, 1, NewChar)
SHOW WINDOW ('Record Viewer') REFRESH


*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*        INSTRSV           Instrs VALID                          
*                                                                
*        Function Origin:                                        
*                                                                
*        From Platform:       MS-DOS                             
*        From Screen:         BSALVAGE,     Record Number:   11  
*        Variable:            Instrs                             
*        Called By:           VALID Clause                       
*        Object Type:         Push Button                        
*        Snippet Number:      1                                  
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*
FUNCTION INSTRSV     &&  Instrs VALID
#REGION 1
Private HelpPath
HelpPath = IIF(File("MANUAL.TXT"), FULLPATH("MANUAL.TXT"), getfile('TXT', "Where is MANUAL.TXT?"))
IF !Empty(HelpPath)
  PRIVATE InstrStr, FileHandle, TempS, i, TempNo
  FileHandle = FOPEN(HelpPath)
  TempNo = FSEEK(FileHandle,0,2)
  IF FileHandle > 0
    TempNo=SrchFile(FileHandle, INT(TempNo/3), TempNo, "3.9 vFPS")
    InstrStr = ''
    TempS=FGETS(FileHandle)
    DO WHILE ATC("4.0 ERROR DETECTION", TempS)==0 AND !FEOF(FileHandle)
      InstrStr = InstrStr + TempS+chr(13)+chr(10)
      TempS=FGETS(FileHandle)
    ENDDO
    DO Bsalvi.spr
    =FCLOSE(FileHandle)
    RETURN
  ENDIF
ENDIF
=rMsgBox("Could not find MANUAL.TXT file. vFPS instructions are in section 3.9 of the file or in the printed manual!","Notice!",0)


*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*        SCANRECS           ScanRecs VALID                       
*                                                                
*        Function Origin:                                        
*                                                                
*        From Platform:       MS-DOS                             
*        From Screen:         BSALVAGE,     Record Number:   27  
*        Variable:            ScanRecs                           
*        Called By:           VALID Clause                       
*        Object Type:         Push Button                        
*        Snippet Number:      2                                  
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*
FUNCTION SCANRECS     &&  ScanRecs VALID
#REGION 1
PRIVATE PrevSec, TempS2, TempS, i
* scan through records
=FSEEK(DBFhandle, FilePos + RecordLen)
PrevSec = SECONDS()
i=RecPosNum
=WaitWin("Checking record - "+STR(RecPosNum+1))

DO WHILE !FEOF(DBFhandle)
  i=i+1
  TempS2=FREAD(DBFHandle, RecordLen)
  TempS = ''
  IF LEN(TempS2) == RecordLen
    TempS = RecVal(TempS2, .T., SensLvl, .F.)
  ENDIF
  IF SECONDS() > PrevSec+2.0
    =WaitWin("Checking record - "+ALLT(STR(i)))
    PrevSec = SECONDS()
  ENDIF
  IF LEN(TempS2)==RecordLen && !FEOF
    IF (LEN(TempS)>0 AND ScanRecs == 1) && scan good records until bad found
      * warning or error record found
      FilePos = FSEEK(DBFhandle, 0 , 1) - 2*RecordLen
      =WaitWin()
      =FilePosV()
      =rMsgBox(TempS + " in next record!", "Notice:",0)
      RETURN
    ENDIF
    IF LEN(TempS)==0 AND ScanRecs == 2 && scan to good record
      * good record found
      FilePos = FSEEK(DBFhandle, 0 , 1) - RecordLen
      =WaitWin()
      =FilePosV()
      =rMsgBox("This record appears OK", "Notice:",0)
      RETURN
    ENDIF
  ENDIF
  IF FEOF(DBFHandle) && EOF - display Last Record & 'No Errors found' message
    FilePos = FSEEK(DBFhandle, 0 , 1) - RecordLen - LEN(TempS2)
    =WaitWin()
    =FilePosV()
    =rMsgBox('End of file reached!', "Notice:",0)
    RETURN
  ENDIF

ENDDO


*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*        BSALVAGEW           Read Level When                     
*                                                                
*        Function Origin:                                        
*                                                                
*                                                                
*        From Platform:       MS-DOS                             
*        From Screen:         BSALVAGE                           
*        Called By:           READ Statement                     
*        Snippet Number:      3                                  
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*
FUNCTION BSALVAGEW     && Read Level When
*
* When Code from screen: BSALVAGE
*
#REGION 1

* MOVE WINDOW _rn60r8lzq by -Bheight/2, 0 && NOT FOR DOS
=ShowText()
